// lib/utils/evaluation-advanced-features.ts (NEW FILE)
/**
 * =============================================================================
 * ADVANCED EVALUATION FEATURES & UTILITIES
 * =============================================================================
 */

import toast from "react-hot-toast";

/**
 * Generate QR code data URL for OTP sharing
 */
export const generateOTPQRCode = async (
  otp: string,
  evaluatorName?: string
): Promise<string | null> => {
  try {
    // Create QR code data with evaluation context
    const qrData = JSON.stringify({
      type: "SPARTA_EVALUATION_OTP",
      otp: otp,
      evaluator: evaluatorName || "Unknown",
      timestamp: new Date().toISOString(),
      expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours
    });

    // For production, you would use a QR code library like 'qrcode'
    // For now, return a placeholder data URL
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = 200;
    canvas.height = 200;

    if (ctx) {
      // Create a simple QR-like pattern (placeholder)
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, 200, 200);
      ctx.fillStyle = "#000000";

      // Draw simple pattern
      for (let i = 0; i < 20; i++) {
        for (let j = 0; j < 20; j++) {
          if ((i + j + otp.charCodeAt(i % otp.length)) % 3 === 0) {
            ctx.fillRect(i * 10, j * 10, 10, 10);
          }
        }
      }

      return canvas.toDataURL();
    }

    return null;
  } catch (error) {
    console.error("Failed to generate QR code:", error);
    return null;
  }
};

/**
 * Enhanced clipboard functionality with multiple formats
 */
export const copyEvaluationData = async (
  data: any,
  format: "text" | "json" | "formatted" = "formatted"
): Promise<boolean> => {
  try {
    let textToCopy = "";

    switch (format) {
      case "text":
        textToCopy = `OTP: ${data.otp}\nLocation: ${data.location}\nTime: ${data.scheduledTime}`;
        break;

      case "json":
        textToCopy = JSON.stringify(data, null, 2);
        break;

      case "formatted":
      default:
        textToCopy = `
ğŸ† SPARTA EVALUATION DETAILS

ğŸ”‘ Verification Code (OTP): ${data.otp || "Not provided"}

ğŸ“ Location: ${data.location || "Not specified"}
${data.venue ? `   Venue: ${data.venue}` : ""}

ğŸ“… Schedule: ${
          data.scheduledTime
            ? new Date(data.scheduledTime).toLocaleString()
            : "Not scheduled"
        }
   Type: ${
     data.meetingType === "physical"
       ? "ğŸŸï¸ Physical Meeting"
       : "ğŸ’» Virtual Meeting"
   }

ğŸ‘¨â€ğŸ« Evaluator: ${data.evaluatorName || "Not assigned"}
${data.evaluatorContact ? `   Contact: ${data.evaluatorContact}` : ""}

ğŸ“‹ Required Equipment:
${
  data.equipment && data.equipment.length > 0
    ? data.equipment.map((item: string) => `   â€¢ ${item}`).join("\n")
    : "   â€¢ No specific equipment required"
}

ğŸ“ Requirements: ${data.requirements || "Standard evaluation requirements"}

${data.additionalNotes ? `\nğŸ“„ Additional Notes:\n${data.additionalNotes}` : ""}

---
Generated by Sparta Athlete Platform
${new Date().toLocaleString()}
        `.trim();
        break;
    }

    // Try modern clipboard API first
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(textToCopy);
    } else {
      // Fallback for older browsers or non-secure contexts
      const textArea = document.createElement("textarea");
      textArea.value = textToCopy;
      textArea.style.position = "fixed";
      textArea.style.left = "-999999px";
      textArea.style.top = "-999999px";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      document.execCommand("copy");
      textArea.remove();
    }

    return true;
  } catch (error) {
    console.error("Failed to copy evaluation data:", error);
    return false;
  }
};

/**
 * Generate calendar event data for evaluation
 */
export const generateCalendarEvent = (evaluationData: any) => {
  const startTime = evaluationData.scheduledTime
    ? new Date(evaluationData.scheduledTime)
    : new Date();
  const endTime = new Date(startTime.getTime() + 60 * 60 * 1000); // 1 hour duration

  const event = {
    title: `Sparta Evaluation - ${evaluationData.evaluatorName || "TBD"}`,
    start: startTime.toISOString().replace(/[-:]/g, "").split(".")[0] + "Z",
    end: endTime.toISOString().replace(/[-:]/g, "").split(".")[0] + "Z",
    description: `
Sparta Athletic Evaluation

OTP: ${evaluationData.otp || "Will be provided"}
Evaluator: ${evaluationData.evaluatorName || "TBD"}
${
  evaluationData.evaluatorContact
    ? `Contact: ${evaluationData.evaluatorContact}`
    : ""
}

Required Equipment:
${
  evaluationData.equipment && evaluationData.equipment.length > 0
    ? evaluationData.equipment.map((item: string) => `â€¢ ${item}`).join("\n")
    : "â€¢ No specific equipment required"
}

${
  evaluationData.additionalNotes
    ? `\nNotes: ${evaluationData.additionalNotes}`
    : ""
}
    `.trim(),
    location: evaluationData.location || "Location TBD",
  };

  return event;
};

/**
 * Create calendar links for different providers
 */
export const createCalendarLinks = (evaluationData: any) => {
  const event = generateCalendarEvent(evaluationData);

  const googleCalendarUrl = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(
    event.title
  )}&dates=${event.start}/${event.end}&details=${encodeURIComponent(
    event.description
  )}&location=${encodeURIComponent(event.location)}`;

  const outlookCalendarUrl = `https://outlook.live.com/calendar/0/deeplink/compose?subject=${encodeURIComponent(
    event.title
  )}&startdt=${event.start}&enddt=${event.end}&body=${encodeURIComponent(
    event.description
  )}&location=${encodeURIComponent(event.location)}`;

  const icsData = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Sparta//Evaluation System//EN
BEGIN:VEVENT
UID:${Date.now()}@sparta.com
DTSTAMP:${new Date().toISOString().replace(/[-:]/g, "").split(".")[0]}Z
DTSTART:${event.start}
DTEND:${event.end}
SUMMARY:${event.title}
DESCRIPTION:${event.description.replace(/\n/g, "\\n")}
LOCATION:${event.location}
END:VEVENT
END:VCALENDAR`;

  const icsBlob = new Blob([icsData], { type: "text/calendar" });
  const icsUrl = URL.createObjectURL(icsBlob);

  return {
    google: googleCalendarUrl,
    outlook: outlookCalendarUrl,
    ics: icsUrl,
    icsFilename: `sparta-evaluation-${evaluationData.otp || "event"}.ics`,
  };
};

/**
 * Generate maps link for location
 */
export const generateMapsLink = (location: string, venue?: string): string => {
  const searchQuery = venue ? `${location} ${venue}` : location;
  return `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(
    searchQuery
  )}`;
};

/**
 * Validate evaluation data completeness with scoring
 */
export const validateEvaluationDataCompleteness = (
  data: any
): {
  score: number;
  maxScore: number;
  completeness: "excellent" | "good" | "fair" | "poor";
  missingFields: string[];
  recommendations: string[];
} => {
  let score = 0;
  const maxScore = 10;
  const missingFields: string[] = [];
  const recommendations: string[] = [];

  // Essential fields (2 points each)
  if (data.otp) {
    score += 2;
  } else {
    missingFields.push("OTP/Verification Code");
    recommendations.push("Request OTP from evaluator");
  }

  if (data.scheduledTime) {
    score += 2;
  } else {
    missingFields.push("Scheduled Time");
    recommendations.push("Confirm evaluation date and time");
  }

  if (data.location) {
    score += 2;
  } else {
    missingFields.push("Location");
    recommendations.push("Get evaluation venue details");
  }

  // Important fields (1 point each)
  if (data.evaluatorName) {
    score += 1;
  } else {
    missingFields.push("Evaluator Name");
    recommendations.push("Get evaluator contact information");
  }

  if (data.evaluatorContact) {
    score += 1;
  } else {
    missingFields.push("Evaluator Contact");
    recommendations.push("Request evaluator phone/email");
  }

  if (data.equipment && data.equipment.length > 0) {
    score += 1;
  } else {
    recommendations.push("Confirm required equipment list");
  }

  if (data.requirements) {
    score += 1;
  } else {
    recommendations.push("Review evaluation requirements");
  }

  // Determine completeness level
  let completeness: "excellent" | "good" | "fair" | "poor";
  if (score >= 9) completeness = "excellent";
  else if (score >= 7) completeness = "good";
  else if (score >= 5) completeness = "fair";
  else completeness = "poor";

  return {
    score,
    maxScore,
    completeness,
    missingFields,
    recommendations,
  };
};

/**
 * Format evaluation data for sharing
 */
export const formatEvaluationForSharing = (
  data: any,
  includeQR: boolean = false
): string => {
  const validation = validateEvaluationDataCompleteness(data);

  return `
ğŸ† SPARTA ATHLETE EVALUATION

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‹ EVALUATION DETAILS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ”‘ VERIFICATION CODE (OTP)
   ${data.otp || "âš ï¸ Not provided - Request from evaluator"}

ğŸ“ LOCATION & VENUE
   ${data.location || "âš ï¸ Not specified - Confirm with evaluator"}
   ${data.venue ? `Venue: ${data.venue}` : ""}

ğŸ“… SCHEDULED TIME
   ${
     data.scheduledTime
       ? new Date(data.scheduledTime).toLocaleString()
       : "âš ï¸ Not scheduled - Confirm date/time"
   }
   Meeting Type: ${
     data.meetingType === "physical" ? "ğŸŸï¸ Physical" : "ğŸ’» Virtual"
   }

ğŸ‘¨â€ğŸ« EVALUATOR INFORMATION
   Name: ${data.evaluatorName || "âš ï¸ Not assigned"}
   Contact: ${data.evaluatorContact || "âš ï¸ Not provided"}

ğŸ“‹ REQUIRED EQUIPMENT
${
  data.equipment && data.equipment.length > 0
    ? data.equipment.map((item: string) => `   âœ“ ${item}`).join("\n")
    : "   â„¹ï¸ No specific equipment listed"
}

ğŸ“ REQUIREMENTS
   ${data.requirements || "Standard evaluation requirements apply"}

${
  data.additionalNotes
    ? `\nğŸ“„ ADDITIONAL NOTES\n   ${data.additionalNotes}`
    : ""
}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š PREPARATION STATUS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Completeness: ${validation.completeness.toUpperCase()} (${validation.score}/${
    validation.maxScore
  })
${
  validation.recommendations.length > 0
    ? `\nğŸ“Œ ACTION ITEMS:\n${validation.recommendations
        .map((r) => `   â€¢ ${r}`)
        .join("\n")}`
    : ""
}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Generated by Sparta Athlete Platform
${new Date().toLocaleString()}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  `.trim();
};

/**
 * Share evaluation via native share API or fallback
 */
export const shareEvaluationData = async (data: any): Promise<boolean> => {
  const shareText = formatEvaluationForSharing(data);

  try {
    if (navigator.share) {
      await navigator.share({
        title: "Sparta Evaluation Details",
        text: shareText,
      });
      return true;
    } else {
      // Fallback to copy to clipboard
      const success = await copyEvaluationData(data, "formatted");
      if (success) {
        toast.success("Evaluation details copied to clipboard!", {
          icon: "ğŸ“‹",
          duration: 3000,
        });
      }
      return success;
    }
  } catch (error) {
    console.error("Failed to share evaluation data:", error);
    return false;
  }
};
